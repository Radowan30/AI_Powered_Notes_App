#Things you need:
-xampp
-composer
-node.js (this will give you npm, vite)
-git
-vs code extensions: php (by devsense), laravel blade formatter, laravel blade snippets, laravel extra intellisense, laravel goto view, auto rename tag, highlight matching tag, prettier, intellisense for css class names in HTML, tailwind css intellisnese

#code to make new laravel project
- composer create-project laravel/laravel folder-name

#after it has finished open the folder using code and then do the following command:
php artisan serve

This will start the server at the specified port (8000)

#Then in NEW terminal, you should install npm packages
- npm install

then do "npm run dev"

this starts a new vite server, which listens for asset changes such as css or js, and it will update the web app realtime


#in a new terminal, do "php artisan list", this will list all the commands you can run in your Laravel project


#Connect the laravel project to the databasw by following this video: https://youtu.be/DCPJOIBeIYM?si=o_TkocqNFxlSuYmg


#to add a new config file to the "config" folder:
do "php artisan config:publish", then write the name to publish it
this will show you the list of files that you can add. Some files arent added by default

so for example, if you want to publish a broadcasting config file, you have to do - "php artisan config:publish broadcasting"


#in web.php of the routes folder, it will contain all the routing of our browser

by default it will be listening for a get request in the '/' folder (the home page), and then view the 'welcome' view. 

all views are located under resources->views. So the 'welcome' above is refering to welcome.blade.php. We dont have to provide the extensions when writing the file name in view().

#Now we will apply a controller for the web.php file, we will replace the function() with the controller

so we should create a controller first. To create a controller - php artisan make:controller WelcomeController

Then in the WelcomeController file, we will have the following code:
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class WelcomeController extends Controller
{
    public function welcome(){
        return view( 'welcome' );
    }
}



Then in the web.php, the code may look like this (The welcome function is replaced with the controller):

<?php

use App\Http\Controllers\NoteController;
use App\Http\Controllers\WelcomeController;
use Illuminate\Support\Facades\Route;

Route::get('/', [WelcomeController::class, 'welcome'])->name('welcome');  //the first welcome is the method of the WelcomeController class, then the second "welcome" is a best practice to provide a name for the route.



#Generating a eloquent model called Note and its related migration
in a new terminal, do "php artisan make:model Note -m"  //the -m means also generate migration

the code the Note.php file should look like this:
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Note extends Model
{
    use HasFactory;
}



what is a migration file?
In Laravel 11, a migration file is a PHP script used to manage and version control your database schema. It provides a programmatic way to define and modify tables, columns, and indexes in your database, enabling developers to easily share and apply changes to the database schema across different environments.

Migration files are typically stored in the `database/migrations` directory of your Laravel project. Each migration file consists of a series of SQL statements that are executed in the order they are written. This allows developers to create, modify, and drop tables and columns in a consistent and predictable manner. Migration files are also used to apply changes to the database schema across different environments, such as development, testing, and production.

In the migration file that is created for the notes model, the following code is available:

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('notes', function (Blueprint $table) {
            $table->id();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('notes');
    }
};


it creates a notes table with the columns that have datatypes id and timestamps. They have not been given names (the names are provided in the brackets)

the columns functions came from the Blueprints.php. Ctrl and left click on the methods will take you to that file

when we do "php artisan migrate" it will run the up() function in the migration file, which will create the notes table in the database. When we do "php artisan migrate:rollback" it will run the down() function in the migration file, which will drop the notes table from the database.

#A factory in laravel is a way to create fake data for testing or seeding(populating the database) the database

to make a factory for the note model: "php artisan make:factory NoteFactory --model=Note"

The factory file will be made


In the seeders -> DatabaseSeeder.php file there is the following code:
public function run(): void
    {
        // User::factory(10)->create();

        User::factory()->create([    //this code is used to create one user in the database it self. If we just want to create it locally we use make() in some other place, not here
            'name' => 'Test User',
            'email' => 'test@example.com',
        ]);
    }


Change the code in this file like so:

<?php

namespace Database\Seeders;

use App\Models\Note;
use App\Models\User;
// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        // User::factory(10)->create();

        User::factory()->create([
            'id' => 1,
            'name' => 'Test User',
            'email' => 'test@example.com',
            'password' => bcrypt('pass123.')
        ]);

        //when typing Note, make sure to choose the Note model so tha the Note model is imported
        Note::factory(100)->create(); //this creates 100 notes in the database
    }
}


#Three ways to execute the seeder:

1) php artisan db:seed

2) php artisan migrate --seed //this will run the migrations first and then the seeder as in the above command

3) php artisan migrate:refresh --seed //this will drop the database and then run the migrations and the seeder as in the above command


*By now, we have the database schema ready and we have some seed data. 

#Now we need to work with this data using the Note controller.

To make this NoteController do:

php artisan make:controller NoteController --resource --model=Note //the --resource indicates that this is a resource controller (which is a controller that handles CRUD operations for a model) and the --model=Note indicates that this controller will handle requests for the Note model

The NoteController file should look like this:

<?php

namespace App\Http\Controllers;

use App\Models\Note;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class NoteController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        return 'index';
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        return 'create';
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        return 'store';
    }

    /**
     * Display the specified resource.
     */
    public function show(Note $note)
    {
        return 'show';
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Note $note)
    {
        return 'edit';
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, Note $note)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Note $note)
    {
        //
    }
}



Only edit until the edit function to return the name of the function


Now in web.php we need to define the corresponding routes for these actions

code in the web.php file should look like this:

<?php

use App\Http\Controllers\NoteController;
use App\Http\Controllers\WelcomeController;
use Illuminate\Support\Facades\Route;

Route::get('/', [WelcomeController::class, 'welcome'])->name('welcome');  //the first welcome is the method of the WelcomeController class, then the second "welcome" is a best practice to provide a name for the route.

Route::get('/note', [NoteController::class, 'index'])->name('note.index');
Route::get('note/create', [NoteController::class, 'create'])->name('note.create');
Route::post('/note', [NoteController::class, 'store'])->name('note.store');
Route::get('note/{id}', [NoteController::class, 'show'])->name('note.show');
Route::get('note/{id}/edit', [NoteController::class, 'edit'])->name('note.edit');
Route::put('/note/{id}', [NoteController::class, 'update'])->name('note.update');
Route::delete('/note/{id}', [NoteController::class, 'destroy'])->name('note.destroy');



See that for each method where the id of a note is used, the NoteController class autmatically passes the corresponding note object in to the function defined in the NoteController class. So this happens for the functions show, edit, update, and destroy.

*Now all the seven route code lines that you see above, can be done with a single line with the resource method:
Route:resource('note', NoteController:class);

So the code in the web.php file should now look like:

<?php

use App\Http\Controllers\NoteController;
use App\Http\Controllers\WelcomeController;
use Illuminate\Support\Facades\Route;

Route::get('/', [WelcomeController::class, 'welcome'])->name('welcome');  //the first welcome is the method of the WelcomeController class, then the second "welcome" is a best practice to provide a name for the route.

// Route::get('/note', [NoteController::class, 'index'])->name('note.index');
// Route::get('note/create', [NoteController::class, 'create'])->name('note.create');
// Route::post('/note', [NoteController::class, 'store'])->name('note.store');
// Route::get('note/{id}', [NoteController::class, 'show'])->name('note.show');
// Route::get('note/{id}/edit', [NoteController::class, 'edit'])->name('note.edit');
// Route::put('/note/{id}', [NoteController::class, 'update'])->name('note.update');
// Route::delete('/note/{id}', [NoteController::class, 'destroy'])->name('note.destroy');

Route::resource('note', NoteController::class);



#By now we have the controller ready, we have the database schema ready, we have some seed data, and we have the routes ready.

#Now we will work on the view files to render the content

We will generate those views under resources

it is a good practice to create a new folder and put all the views related to that specific resource in that folder. So we will create a new folder called "notes" under resources/views

We can generate these using artisan by:

For the index view:
php artisan make:view note.index   //note.index means create the note folder and index.blade.php file inside it

For the create view:
php artisan make:view note.create 

For the edit view:
php artisan make:view note.edit

For the show view:
php artisan make:view note.show


Edit the view files as you see fit 

Then make the controller return the view files
For example, this is how the create function should look like:
public function create()
    {
        return view('note.create');
    }

#Now we will make layouts that can be used in other blade files

go to views and create a new folder called components, in it make a file called layout.blade.php

laravel has a separate section of UI components

Basically the layout file stuff can be used as components in other files using this tag <x-layout></x-layout>

the code in the layout.blade.php file should look like this:
<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Laravel</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css?family=figtree:400,500,600&display=swap" rel="stylesheet" />

    <!-- Styles / Scripts -->
    @if (file_exists(public_path('build/manifest.json')) || file_exists(public_path('hot')))
        @vite(['resources/css/app.css', 'resources/js/app.js'])
    @else
    @endif
</head>

<body class="font-sans antialiased dark:bg-black dark:text-white/50">
    {{ $slot }}
    <!--the {{}} is how you output variables, and the $slot is a special variable for the view content -->
</body>

</html>

//the {{}} in the <body> tag above is how you output variables, and the $slot is a special variable for the view content


Now in the index.blade.file for example, we can use the layout like this:

<x-layout>
    <h1>index</h1>
</x-layout>


The <h1> tag (or any child that is given to this <x-layout> tag) is assigned to the $slot variable in the layout file. 


#Now we will select the content from the database and pass them to views

we need to set this up in the controller files

The notes controller file code will look like this (only the changed code is shown):

class NoteController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        $notes = Note::query()->orderBy('created_at', 'desc')->paginate(); //this query retrieves all notes, if we use the get() method at the end, ordered by creation date in descending order. We change the get() method to paginate()
        // dd($notes); //dd is a debugging tool that allows you to print the value of a variable to the console. It is like console log in JS.
        return view('note.index', ['notes' => $notes]); //"note.index" means the index.blade file in the note folder. The second argument of the view function, which is the [] in which there are the key value pair array allows us to pass a variable to the view. The notes in quotes in the array is the variable that is in the blade file, this variable is created in the note.index file. Instead of array we can also use compact function
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        return view('note.create');
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        return 'store';
    }

    /**
     * Display the specified resource.
     */
    public function show(Note $note)
    {
        return view('note.show', ['note' => $note]);
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Note $note)
    {
        return view('note.edit', ['note' => $note]);
    }


So we have passed the $notes array to the note/index.blade.php file

The code in that file looks like this now:

<x-layout>
    <div class="note-container">
        {{-- For each links, we can manually set the link to each page. But this is not the perfect solution in laravel. We can generate the routes based on the route names  --}}
        <a href="{{ route('note.create') }}" class="new-note-btn">
            New Note
        </a>

        <div class="notes">
            {{-- now we will render every notes using a for each directive. There are many directives in laravel that can be accessed with the @ symbol. Below, each element in hte $notes array is assigned to the $note variable.
            
            The Str::words() method allows us to set the number of words we want to use
            --}}
            @foreach ($notes as $note)
                <div class="note">
                    <div class="note-body">
                        {{ Str::words($note->note, 30) }}
                    </div>
                    <div class="note-buttons">
                        {{-- Below in href="{{route('note.show', $note)}}", we actually need to pass the id of the note to have the right note shown and it is also how the route is setup in the web.php file. So we can either give $note->id as the second argument, or just $note in which case it'll just use the primary key (the id) --}}
                        <a href="{{ route('note.show', $note) }}" class="note-edit-button">View</a>
                        <a href="{{ route('note.edit', $note) }}" class="note-edit-button">Edit</a>
                        <button href="#" class="note-delete-button">Delete</button>
                    </div>
                </div>
            @endforeach
        </div>
    </div>
</x-layout>



now the notes are shown in the notes directory.

#Now to add css styling

We go to the app.css file under css

We copy pasted the css styling from the tutorial's github repo

But the app.css file is not included automatically

We have to include the app.css file in the layout.blade.php file

We could do this by putting the app.css file in the public folder, but this is not ideal. 

So we will use vite during development.

In the layout.blade.php we should have this line: @vite(['resources/css/app.css', 'resources/js/app.js'])
But it seems it is already added when the project is created

The vite server is including the app.css and app.js files in the application server

But for production, we cant serve by the vite server, we have to build those asset files

So we firsst kill the vite/node server, then we have to do npm run build, which builds the assets in the public folder, under public build assets. So when we put this on the server, these files will be served. 

Recommendation is that we have the vite server running during development, and then do npm run build deploying/production

#Now we do the proper html and css for the create, show and edit blade files

Code in create.blade.php:
<x-layout>
    <div class="note-container single-note">
        <h1>Create new note</h1>
        <form action="{{route("note.store")}}" method="POST" class="note">
            <textarea name="note" rows="10" class="note-body" placeholder="Enter your note here"></textarea>
            <div class="note-buttons">
                <a href="{{route("note.index")}}" class="note-cancel-button">Cancel</a>
                <button class="note-submit">Submit</button>
            </div>
        </form>
    </div>
</x-layout>

code in edit.blade:

<x-layout>
    <div class="note-container single-note">
        <h1>Edit your note</h1>
        <form action="{{ route('note.update', $note) }}" method="POST" class="note">
            <textarea name="note" rows="10" class="note-body" placeholder="Enter your note here">{{ $note->note }}</Label></textarea>
            <div class="note-buttons">
                <a href="{{ route('note.index') }}" class="note-cancel-button">Cancel</a>
                <button class="note-submit">Submit</button>
            </div>
        </form>
    </div>
</x-layout>

code in show.blade:
<x-layout>
    <div class="note-container single-note">
        <div class="note-header">
            <h1>Note: {{ $note->created_at }}</h1>
            <div class="note-buttons">
                <a href="{{ route('note.edit', $note) }}" class="note-edit-button">Edit</a>
                <button class="note-delete-button">Delete</button>
            </div>
        </div>
        <div class="note">
            <div class="note-body">
                {{ $note->note }}
            </div>
        </div>
    </div>
</x-layout>


Now each in each blade file we need to include the CSRF token. So first we have to work on the store() function in the NoteController

First we will see how it looks like without csrf tokens

Code in NoteController of the store function:

public function store(Request $request)
    {
        $data = $request->validate(['note' => ['required', 'string']]); //validates if the note data in the request is a required and string or not, and then it returns something which gets stored in the data

        $data['user_id'] = 1; //We assign the user_id in the request to 1, so that the note is created with this user id. Later will dynamically assign user id from the currently authenticated user.
        $note = Note::create($data); //make a note modal with the verified request data. The new note should be automatically added to the database here.
        //Here we are passing an associative array ($data) to the create() metho of the Note modal. But we need to specifiy for the Note modal which fields of the associative array it should take (and also which fields of the database table it should fill). We do that in the Note.php file under Models

        //after you create a new note, we should be directed to the note/show.blade.php file, and we should also pass a session message
        return to_route('note.show', $note)->with('message', 'Note was created');

    }


//the code above creates the new note in the db

#Now we will handle displaying the session message we pass to the note.show page

go to the layout file

we add this line of code to the body:

<body class="font-sans antialiased dark:bg-black dark:text-white/50">
    @session('message')
        <div class="success-message">
            {{ session('message') }}
        </div>
    @endsession
    {{ $slot }}
    <!--the {{}} is how you output variables, and the $slot is a special variable for the view content -->
</body>


but the message is not shown when we create a new note (and a Page expired message is shown)because the CSRF token is note implemented

we add the CSRF token into create.blade file (and in any file to which we want to pass messages using the to_route() method used in the Controller function)

code in the create.blade file:

<x-layout>
    <div class="note-container single-note">
        <h1>Create new note</h1>
        <form action="{{ route('note.store') }}" method="POST" class="note">
            @csrf
            {{-- csrf is a cross site request forgery methodology to prevent sumbission of forms from someone else's website to your website --}}
            <textarea name="note" rows="10" class="note-body" placeholder="Enter your note here"></textarea>
            <div class="note-buttons">
                <a href="{{ route('note.index') }}" class="note-cancel-button">Cancel</a>
                <button class="note-submit">Submit</button>
            </div>
        </form>
    </div>
</x-layout>

Now the notification as well as the new note shortened view is shown in the show.blade returned html webpage

#Now lets work on the update view, when a note is edited

-you should probably use @csrf token where ever there is a form

-in the edit.blade file, a put request is necessary inorder to update a specific note. But the form is sent with a POST request. So we need to use the directive @method('PUT'), which overrides the POST method mentioned in method of the form. So as a result, the PUT method in the routes in web.php will be matched with this method

- flow of laravel project interactions: user clicks button(that sends a request) -> web.php (the appropriate route) -> The appropriate function inside the Controller -> The appropriate view file served to client (user)

The code for the update function in the Notecontroller is like this:
public function update(Request $request, Note $note)
    {
        $data = $request->validate(['note' => ['required', 'string']]); //validates if the note data in the request is a required and string or not, and then it returns something which gets stored in the data

        //no setting user_id as in store, as we dont change the user_id/set the user_id ourselves/it automatically knows
        //instead of making a new note and passing the request data to it like this $note = Note::create($data);  we will pass the data to the existing note we get from the argument
        $note->update($data);

        //after you create a new note, we should be directed to the note/show.blade.php file, and we should also pass a session message
        return to_route('note.show', $note)->with('message', 'Note was updated');
    }


#Now we will handle the delete button function in the show page and the note lising page

code in index file:

<x-layout>
    <div class="note-container">
        {{-- For each links, we can manually set the link to each page. But this is not the perfect solution in laravel. We can generate the routes based on the route names  --}}
        <a href="{{ route('note.create') }}" class="new-note-btn">
            New Note
        </a>

        <div class="notes">
            {{-- now we will render every notes using a for each directive. There are many directives in laravel that can be accessed with the @ symbol. Below, each element in hte $notes array is assigned to the $note variable.
            
            The Str::words() method allows us to set the number of words we want to use
            --}}
            @foreach ($notes as $note)
                <div class="note">
                    <div class="note-body">
                        {{ Str::words($note->note, 30) }}
                    </div>
                    <div class="note-buttons">
                        {{-- Below in href="{{route('note.show', $note)}}", we actually need to pass the id of the note to have the right note shown and it is also how the route is setup in the web.php file. So we can either give $note->id as the second argument, or just $note in which case it'll just use the primary key (the id) --}}
                        <a href="{{ route('note.show', $note) }}" class="note-edit-button">View</a>
                        <a href="{{ route('note.edit', $note) }}" class="note-edit-button">Edit</a>
                        {{-- When we want to delete something, a delete request has to be sent to the delete route. So instead having a button, it needs to be form, that submits to the note.destry route using the POST method (as we are modifying something), but then we also have to provid the @csrf and the @method('DELETE') directives --}}
                        <form action="{{route('note.destroy', $note)}}" method="POST">
                            @csrf
                            @method('DELETE')
                            <button class="note-delete-button">Delete</button>
                        </form>
                    </div>
                </div>
            @endforeach
        </div>
    </div>
</x-layout>


code in show file:

<x-layout>
    <div class="note-container single-note">
        <div class="note-header">
            <h1>Note: {{ $note->created_at }}</h1>
            <div class="note-buttons">
                <a href="{{ route('note.edit', $note) }}" class="note-edit-button">Edit</a>
                {{-- When we want to delete something, a delete request has to be sent to the delete route. So instead having a button, it needs to be form, that submits to the note.destry route using the POST method (as we are modifying something), but then we also have to provid the @csrf and the @method('DELETE') directives --}}
                <form action="{{ route('note.destroy', $note) }}" method="POST">
                    @csrf
                    @method('DELETE')
                    <button class="note-delete-button">Delete</button>
                </form>
            </div>
        </div>
        <div class="note">
            <div class="note-body">
                {{ $note->note }}
            </div>
        </div>
    </div>
</x-layout>


#Now we will create page changing function in laravel (Pagination)

All we have to do in the index.blade.php file os add the following line at the end of the main div:
{{$notes->links()}}

This works because we set the notes query as a paginate() in the index() function definition in the NotesController

The pagination will at first have very bad layout, as the tailwind css wont be made. (but for me it was alright from the beginnign because I copied all the styles from the guy's repo)



#Now we will implement authentication with email verification using Breeze

Back up (copy paste somewhere else) the app.css and web.php files somewhere else, as these files will get overwritten by Breeze. 

Install Breeze using composer:

i) composer require laravel/breeze --dev   //this installs breeze as a dev dependency

then do:

ii) php artisan breeze:install

iii) choose blade, then choose the appropriate operations. In the test choosing screen you can just press enter to skip


Then you will see that the routes dont work, because the routes have been overwritten


** Ran into an issue after doing composer require laravel/breeze --dev and php artisan breeze:install, where there was a problem with long path paths. I followed th following steps to fix it:

1. Edit the Registry:

Press Win + R, type regedit, and hit Enter.
Navigate to:
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem.
Find or create a DWORD named LongPathsEnabled.
Set its value to 1.
Restart your machine.


2. Clean the Composer Cache
Sometimes corrupted or outdated cache files can cause installation problems. Run the following command to clean the Composer cache:

composer clear-cache

3. (First do git init if you haven't done so) then Update Git Configuration
Git can encounter issues with long paths. Update Git to handle long paths explicitly:

git config --global core.longpaths true


#Now, when we register, we are automatically verified. 

#If we want email verification (with a verification email sent), we need to go to the user.php file and make the User class implement the MustVerifyEmail class. The code looks like this in the User.php file:

<?php

namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }
}


*The verification Email is not actually sent to the email, it is stored locally under storage->logs->laravel.log for local development, because in the .env file, the MAIL_MAILER is set to log and not a mailing service. Inside of it you'll have the verification email as well as the link to go log in


#Now lets recover web.php. The current code in it is:

<?php

use App\Http\Controllers\ProfileController;
use Illuminate\Support\Facades\Route;

Route::get('/', function () {
    return view('welcome');
});

Route::get('/dashboard', function () {
    return view('dashboard');
})->middleware(['auth', 'verified'])->name('dashboard'); //here, there are two middlewares- the auth middleware checks if the user is authenticated and the verified middleware checks if the user is verified. If one of them is not satisfied, then we cant access the dashboard page.

Route::middleware('auth')->group(function () {
    Route::get('/profile', [ProfileController::class, 'edit'])->name('profile.edit');
    Route::patch('/profile', [ProfileController::class, 'update'])->name('profile.update');
    Route::delete('/profile', [ProfileController::class, 'destroy'])->name('profile.destroy');
});

require __DIR__.'/auth.php';



*the middleware is a class that sits betn the user's request and the controller. The middleware either blocks the request or returns a modified response.

*What is Middleware in Laravel?
Middleware in Laravel acts like a checkpoint or gatekeeper for HTTP requests. It allows you to filter and control access to parts of your application by performing tasks before or after a request is handled by your application.

*How Middleware Works Internally:
Middleware acts on the request-response cycle:

Request Enters the Application:

Middleware runs before the request reaches your controller or route.
It performs checks or modifications (e.g., verify authentication, log requests).
Request Proceeds to the Route/Controller:

If all middleware checks pass, the request is processed by the route or controller.
Response is Sent Back:

Middleware can also run after the response is generated to perform tasks like modifying headers or logging.


*Summary:
Middleware is like a security checkpoint that filters and controls requests as they travel into and out of your application. It’s a powerful way to handle common tasks efficiently while keeping your code organized and modular.



#Clink on the login link in te log file first

#Then change the code so that the code in Web.php should look like this:
<?php

use App\Http\Controllers\NoteController;
use App\Http\Controllers\ProfileController;
use Illuminate\Support\Facades\Route;

// Route::get('/', function () {
//     return view('welcome');
// });

// Route::get('/dashboard', function () {
//     return view('dashboard');
// })->middleware(['auth', 'verified'])->name('dashboard'); //here, there are two middlewares- the auth middleware checks if the user is authenticated and the verified middleware checks if the user is verified. If one of them is not satisfied, then we cant access the dashboard page.

Route::middleware(['auth', 'verified'])->group(function () { //here, there are two middlewares- the auth middleware checks if the user is authenticated and the verified middleware checks if the user is verified. If one of them is not satisfied, then we cant access the note routes that are specified below / is specified by the single line at the bottom


    // Route::get('/note', [NoteController::class, 'index'])->name('note.index');
// Route::get('note/create', [NoteController::class, 'create'])->name('note.create');
// Route::post('/note', [NoteController::class, 'store'])->name('note.store');
// Route::get('note/{id}', [NoteController::class, 'show'])->name('note.show');
// Route::get('note/{id}/edit', [NoteController::class, 'edit'])->name('note.edit');
// Route::put('/note/{id}', [NoteController::class, 'update'])->name('note.update');
// Route::delete('/note/{id}', [NoteController::class, 'destroy'])->name('note.destroy');

    Route::resource('note', NoteController::class);
});

Route::middleware('auth')->group(function () {  //the middle waregroup, which has the routes. The user needs to be authenticated in order to access the profile page specified below
    Route::get('/profile', [ProfileController::class, 'edit'])->name('profile.edit');
    Route::patch('/profile', [ProfileController::class, 'update'])->name('profile.update');
    Route::delete('/profile', [ProfileController::class, 'destroy'])->name('profile.destroy');
});

require __DIR__ . '/auth.php';



#Now we have to restore the styles in the app.css file. Just copy paste the code from the file that was backed up

#If it doesnt seem to be showing the styles, restart the vite server

#Now we will chage the layout of our notes page to be similar to the breeze dashboard layout (which  is in resources->views).

-the dashboard uses the x-app-layout, whcih is in views->layouts->app.blade.php

-what we can do is, in index.blade.php (the file that shows all our notes), and change the <x-layout> to <x-app-layout>
-this will give it the same layout as the breeze dashboard
- and we do the same thing for all the note view files.

-we will first see a route[dashboard] not found error, as we deleted the route

-so what we can do in the web.php file is to set a route that redirects from the '/' to '/note' and give it the name 'dashboard'. So now, whenever the code tries to redirect to the dashboard, itll redirecto to '/' instead, which inturn redirects to '/note'

-so now, even though we are redirecting twice, it is a quick way to have the dashboard as our notes app

-at first, you'll see that any user sees all the notes in the database. This is because the notes route is not filtered according to the currently authenticated user.

-so we have to implement this login in the index() function def of the NoteController

the code in the Notecontroller should look like this:


public function index()
    {
        $notes = Note::query()
            ->where('user_id', request()->user()->id)  //only get the notes rows that have the user_id column matching the currently authenticated user
            ->orderBy('created_at', 'desc')
            ->paginate(); //this query retrieves all notes, if we use the get() method at the end, ordered by creation date in descending order. We change the get() method to paginate()
        // dd($notes); //dd is a debugging tool that allows you to print the value of a variable to the console. It is like console log in JS.
        return view('note.index', ['notes' => $notes]); //"note.index" means the index.blade file in the note folder. The second argument of the view function, which is the [] in which there are the key value pair array allows us to pass a variable to the view. The notes in quotes in the array is the variable that is in the blade file, this variable is created in the note.index file. Instead of array we can also use compact function
    }


 public function store(Request $request)
    {
        $data = $request->validate(['note' => ['required', 'string']]); //validates if the note data in the request is a required and string or not, and then it returns something which gets stored in the data

        $data['user_id'] = $request->user()->id; //We assign the user_id in the request to 1, so that the note is created with this user id. Later will dynamically assign user id from the currently authenticated user, by using the $request or using $request->user()->id
        $note = Note::create($data); //make a note modal with the verified request data. The new note should be automatically added to the database here.
        //Here we are passing an associative array ($data) to the create() metho of the Note modal. But we need to specifiy for the Note modal which fields of the associative array it should take (and also which fields of the database table it should fill). We do that in the Note.php file under Models

        //after you create a new note, we should be directed to the note/show.blade.php file, and we should also pass a session message
        return to_route('note.show', $note)->with('message', 'Note was created');

    }

-there is a problem where if the note id is set to another value in the browser link, then that not is visible to everyone, so to prevent that, we restrict that in the show() function using an if statement:

public function show(Note $note)
    {
        if($note->user_id !== request()->user()->id){
            abort(403);
        }
        return view('note.show', ['note' => $note]);
    }

same thing has to be done in the edit, update, delete functions:

public function edit(Note $note)
    {
        if ($note->user_id !== request()->user()->id) {
            abort(403);
        }
        return view('note.edit', ['note' => $note]);
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, Note $note)
    {
        if ($note->user_id !== request()->user()->id) {
            abort(403);
        }

        $data = $request->validate(['note' => ['required', 'string']]); //validates if the note data in the request is a required and string or not, and then it returns something which gets stored in the data

        //no setting user_id as in store, as we dont change the user_id/set the user_id ourselves/it automatically knows
        //instead of making a new note and passing the request data to it like this $note = Note::create($data);  we will pass the data to the existing note we get from the argument
        $note->update($data);

        //after you create a new note, we should be directed to the note/show.blade.php file, and we should also pass a session message
        return to_route('note.show', $note)->with('message', 'Note was updated');
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Note $note)
    {
        if ($note->user_id !== request()->user()->id) {
            abort(403);
        }
        $note->delete();
        return to_route('note.index')->with('message', 'Note was deleted');
    }
}

#Now for final touches. 

-we will change the 'dashboard' tab text to notes and also add some css styling

-to do this we will go to the navigation.blade.php file (in views->layouts) to get the 'dashboard' tab, and we no longer need the layout.blade.php file (we can delete it)


changes these codes:

<!-- Navigation Links -->
                <div class="hidden space-x-8 sm:-my-px sm:ms-10 sm:flex">
                    <x-nav-link :href="route('note.index')" :active="request()->routeIs('note.index')">
                        {{ __('Notes') }}
                    </x-nav-link>
                </div>
            </div>

<!-- Responsive Navigation Menu -->
    <div :class="{ 'block': open, 'hidden': !open }" class="hidden sm:hidden">
        <div class="pt-2 pb-3 space-y-1">
            <x-responsive-nav-link :href="route('note.index')" :active="request()->routeIs('note.index')">
                {{ __('Notes') }}
            </x-responsive-nav-link>
        </div>



-added some padding to the index file:

<x-app-layout>
    <div class="note-container py-12">
        {{-- For each links, we can manually set the link to each page. But this is not the perfect solution in laravel. We can generate the routes based on the route names  --}}
        <a href="{{ route('note.create') }}" class="new-note-btn">
            New Note
        </a>

        <div class="notes">
            {{-- now we will render every notes using a for each directive. There are many directives in laravel that can be accessed with the @ symbol. Below, each element in hte $notes array is assigned to the $note variable.
            
            The Str::words() method allows us to set the number of words we want to use
            --}}
            @foreach ($notes as $note)
                <div class="note">
                    <div class="note-body">
                        {{ Str::words($note->note, 30) }}
                    </div>
                    <div class="note-buttons">
                        {{-- Below in href="{{route('note.show', $note)}}", we actually need to pass the id of the note to have the right note shown and it is also how the route is setup in the web.php file. So we can either give $note->id as the second argument, or just $note in which case it'll just use the primary key (the id) --}}
                        <a href="{{ route('note.show', $note) }}" class="note-edit-button">View</a>
                        <a href="{{ route('note.edit', $note) }}" class="note-edit-button">Edit</a>
                        {{-- When we want to delete something, a delete request has to be sent to the delete route. So instead having a button, it needs to be form, that submits to the note.destry route using the POST method (as we are modifying something), but then we also have to provid the @csrf and the @method('DELETE') directives --}}
                        <form action="{{ route('note.destroy', $note) }}" method="POST">
                            @csrf
                            @method('DELETE')
                            <button class="note-delete-button">Delete</button>
                        </form>
                    </div>
                </div>
            @endforeach
        </div>
        {{ $notes->links() }}
    </div>
</x-app-layout>



-changed the heading of the show page a little bit:

<x-app-layout>
    <div class="note-container single-note">
        <div class="note-header">
            <h1 class="text-3xl py-4">Note: {{ $note->created_at }}</h1>
            <div class="note-buttons">
                <a href="{{ route('note.edit', $note) }}" class="note-edit-button">Edit</a>
                {{-- When we want to delete something, a delete request has to be sent to the delete route. So instead having a button, it needs to be form, that submits to the note.destry route using the POST method (as we are modifying something), but then we also have to provid the @csrf and the @method('DELETE') directives --}}
                <form action="{{ route('note.destroy', $note) }}" method="POST">
                    @csrf
                    @method('DELETE')
                    <button class="note-delete-button">Delete</button>
                </form>
            </div>
        </div>
        <div class="note">
            <div class="note-body">
                {{ $note->note }}
            </div>
        </div>
    </div>
</x-app-layout>


-also changed the heading a bit for the edit page:

<x-app-layout>
    <div class="note-container single-note">
        <h1 class="text-3xl py-4">Edit your note</h1>
        <form action="{{ route('note.update', $note) }}" method="POST" class="note">
            @csrf
            @method('PUT')
            <textarea name="note" rows="10" class="note-body" placeholder="Enter your note here">{{ $note->note }}</textarea>
            <div class="note-buttons">
                <a href="{{ route('note.index') }}" class="note-cancel-button">Cancel</a>
                <button class="note-submit">Submit</button>
            </div>
        </form>
    </div>
</x-app-layout>


-now giving some padding to the pagination. Go to the index.blade page and then make a div and then put the pagination inside there:


#Now, we can customize the 403 Forbidden page that the user sees when they try to see another note

-for this we have to create a new folder called "errors" under views, create in it the file 403.blade.php
Then the code can be something like this in that file:

<x-app-layout>
    <h1>Forbidden</h1>
</x-app-layout>





















